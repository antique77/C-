/* 
这个程序与前两个练习类似，但更加一般化了。它允许调用程序把逗号放在大数
的内部，去除多余的前导零以及提供一个浮动美元符号等。
这个函数的操作类似于IBM370机器上的Edit和Mark指令。它的原型如下:
char *edit( char *pattern,char const*digits );
它的基本思路很简单。模式(pattem)就是一个图样，处理结果看上去应该像它的样
子。数字字符串中的字符根据这个图样所提供的方式从左向右复制到模式字符串。
数字字符串的第1位有效数字很重要。结果字符串中所有在第1位有效数字之前
的字符都由一个“填充”字符代替，函数将返回一个指针，它所指向的位置正是
第1位有效数字存储在结果字符串中的位置(调用程序可以根据这个返回指针，
把一个浮动美元符号放在这个值左边的毗邻位置)。这个函数的输出结果就像支票
上打印的结果一样一一这个值左边所有的空白由星号或其他字符填充。
在描述这个函数的详细处理过程之前，看一些这个操作的例子是有很帮助的。为
了清晰起见，符号¤用于表示空格。结果字符串中带下划线的那个数字就是返回
值指针所指向的字符(也就是第1位有效数字)，如果结果字符串中不存在带下划
线的字符，说明函数的返回值是个NULL 指针。

现在，让我们讨论这个函数的细节。函数的第1个参数就是模式，模式字符串的
第1个字符就是“填充字符”。函数使数字字符串修改模式字符串中剩余的字符来
产生结果字符串。在处理过程中，模式字符串将被修改。输出字符串不可能比原
先的模式字符串更长，所以不存在溢出第1个参数的危险(因此不需要对此进行
检查)。
模式是从左向右逐个字符进行处理的。每个位于填充字符后面的字符的处理结果
将是三中选一:(a)原样保留，不作修改;(b)被一个数字字符串中的字符代替;(c)
被填充字符代替。
数字字符串也是从左向右进行处理的，但它本身在处理过程中绝不会被修改。虽
然它被称为“数字字符串”，但是它也可以包含任何其他字符，如上面的例子之一
所示。但是，数字字符串中的空格应该和数字0一样对待(它们的处理结果相同)。
函数必须保持一个“有效”标志，用于标志是否有任何有效数字从数字字符串复
制到模式字符串。数字字符串中的前导空格和前导0并非有效数字，其余的字符
都是有效数字。
如果模式字符串或数字字符串有一个是NULL，那就是个错误。在这种情况下，
函数应该立即返回NULL。
下面这个表列出了所有需要的处理过程。列标题“signif”就是有效标志。“模式”
和“数字”分别表示模式字符串和数字字符串的下一个字符。表的左边列出了所
有可能出现的不同情况，表的右边描述了每种情况需要的处理过程。例如，如果
下一个模式字符是#，有效标志就设为假。数字字符串的下一个字符是‘0'，所以
用一个填充字符代替模式字符串中的#字符，对有效标志不作修改。
*/


#include <stdio.h>
int main()
{
	printf("Hello world\n");
	return (0);
}

